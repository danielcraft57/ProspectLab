"""
Service d'analyse de sécurité (Pentest)
Détection de vulnérabilités et failles de sécurité
"""

import subprocess
import shutil
import json
import re
import os
from urllib.parse import urlparse
from typing import Dict, List, Optional
import requests
from bs4 import BeautifulSoup

# Importer la configuration
try:
    from config import WSL_DISTRO, WSL_USER, PENTEST_TOOL_TIMEOUT
except ImportError:
    # Valeurs par défaut si config n'est pas disponible
    WSL_DISTRO = os.environ.get('WSL_DISTRO', 'kali-linux')
    WSL_USER = os.environ.get('WSL_USER', 'loupix')
    PENTEST_TOOL_TIMEOUT = int(os.environ.get('PENTEST_TOOL_TIMEOUT', '120'))


class PentestAnalyzer:
    """
    Analyseur de sécurité pour détecter les vulnérabilités
    ⚠️ À utiliser uniquement avec autorisation écrite
    """
    
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self._check_tools_availability()
    
    def _check_tools_availability(self):
        """Vérifie la disponibilité des outils de pentest"""
        self.wsl_available = shutil.which('wsl') is not None
        # Utiliser les variables d'environnement pour WSL
        self.wsl_cmd_base = ['wsl', '-d', WSL_DISTRO, '-u', WSL_USER] if self.wsl_available else None
        
        # Vérifier les outils disponibles
        self.tools = {
            'sqlmap': self._check_tool('sqlmap'),
            'wpscan': self._check_tool('wpscan'),
            'nikto': self._check_tool('nikto'),
            'wapiti': self._check_tool('wapiti'),
            'nmap': self._check_tool('nmap'),
            'sslscan': self._check_tool('sslscan'),
        }
    
    def _check_tool(self, tool_name: str) -> bool:
        """Vérifie si un outil est disponible"""
        if shutil.which(tool_name):
            return True
        if self.wsl_available:
            try:
                result = subprocess.run(
                    self.wsl_cmd_base + ['which', tool_name],
                    capture_output=True,
                    text=True,
                    timeout=3
                )
                return result.returncode == 0
            except:
                pass
        return False
    
    def _run_wsl_command(self, command: List[str], timeout: int = None) -> Dict:
        """
        Exécute une commande via WSL
        Optimisé pour réduire la surcharge de démarrage WSL
        """
        if not self.wsl_available:
            return {'error': 'WSL non disponible'}
        
        # Utiliser le timeout depuis la config si non spécifié
        if timeout is None:
            timeout = PENTEST_TOOL_TIMEOUT
        
        try:
            # Utiliser directement subprocess.run avec les options optimisées
            cmd = self.wsl_cmd_base + command
            
            # Utiliser start_new_session=False pour éviter les problèmes de groupe
            # Utiliser encoding='utf-8' avec errors='ignore' pour éviter les erreurs Unicode
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='ignore',
                timeout=timeout,
                start_new_session=False
            )
            return {
                'success': result.returncode == 0,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode
            }
        except subprocess.TimeoutExpired:
            return {'error': 'Timeout'}
        except Exception as e:
            return {'error': str(e)}
    
    def scan_sql_injection(self, url: str) -> Dict:
        """Scan SQL injection avec SQLMap (mode passif)"""
        vulnerabilities = []
        
        if not self.tools['sqlmap']:
            return {'error': 'sqlmap non disponible', 'vulnerabilities': []}
        
        # Test rapide en mode passif (sans exploitation)
        result = self._run_wsl_command([
            'sqlmap',
            '-u', url,
            '--batch',
            '--crawl=2',
            '--level=1',
            '--risk=1',
            '--forms',
            '--threads=5'
        ], timeout=120)
        
        if result.get('success'):
            output = result['stdout']
            if 'injection' in output.lower() or 'vulnerable' in output.lower():
                vulnerabilities.append({
                    'type': 'SQL Injection',
                    'severity': 'High',
                    'description': 'Possible injection SQL détectée',
                    'details': output[:500]
                })
        
        return {
            'vulnerabilities': vulnerabilities,
            'scan_completed': result.get('success', False)
        }
    
    def scan_wordpress(self, url: str) -> Dict:
        """Scan WordPress avec WPScan"""
        vulnerabilities = []
        info = {}
        
        if not self.tools['wpscan']:
            return {'error': 'wpscan non disponible', 'vulnerabilities': []}
        
        # Scan WordPress (sans force brute par défaut)
        result = self._run_wsl_command([
            'wpscan',
            '--url', url,
            '--no-update',
            '--format', 'json'
        ], timeout=180)
        
        if result.get('success'):
            try:
                data = json.loads(result['stdout'])
                if 'version' in data:
                    info['version'] = data['version']
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        vulnerabilities.append({
                            'type': 'WordPress Vulnerability',
                            'severity': vuln.get('severity', 'Medium'),
                            'title': vuln.get('title', ''),
                            'description': vuln.get('description', '')
                        })
            except:
                # Si JSON invalide, parser le texte
                if 'vulnerable' in result['stdout'].lower():
                    vulnerabilities.append({
                        'type': 'WordPress Vulnerability',
                        'severity': 'Medium',
                        'description': 'Vulnérabilités WordPress détectées'
                    })
        
        return {
            'vulnerabilities': vulnerabilities,
            'info': info,
            'scan_completed': result.get('success', False)
        }
    
    def scan_nikto(self, url: str) -> Dict:
        """Scan de vulnérabilités web avec Nikto"""
        vulnerabilities = []
        
        if not self.tools['nikto']:
            return {'error': 'nikto non disponible', 'vulnerabilities': []}
        
        result = self._run_wsl_command([
            'nikto',
            '-h', url,
            '-Format', 'txt'
        ], timeout=300)
        
        if result.get('success'):
            output = result['stdout']
            # Parser les résultats Nikto
            for line in output.split('\n'):
                if '+ ' in line and ('OSVDB' in line or 'found' in line.lower()):
                    vuln_match = re.search(r'\+ (.+)', line)
                    if vuln_match:
                        vulnerabilities.append({
                            'type': 'Web Vulnerability',
                            'severity': 'Medium',
                            'description': vuln_match.group(1)
                        })
        
        return {
            'vulnerabilities': vulnerabilities[:20],  # Limiter à 20
            'scan_completed': result.get('success', False)
        }
    
    def scan_wapiti(self, url: str) -> Dict:
        """Scan de vulnérabilités avec Wapiti"""
        vulnerabilities = []
        
        if not self.tools['wapiti']:
            return {'error': 'wapiti non disponible', 'vulnerabilities': []}
        
        result = self._run_wsl_command([
            'wapiti',
            '-u', url,
            '-f', 'json',
            '--scope', 'folder'
        ], timeout=300)
        
        if result.get('success'):
            try:
                data = json.loads(result['stdout'])
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        vulnerabilities.append({
                            'type': vuln.get('type', 'Unknown'),
                            'severity': vuln.get('severity', 'Medium'),
                            'description': vuln.get('description', ''),
                            'parameter': vuln.get('parameter', '')
                        })
            except:
                pass
        
        return {
            'vulnerabilities': vulnerabilities,
            'scan_completed': result.get('success', False)
        }
    
    def check_security_headers(self, url: str) -> Dict:
        """Vérifie les en-têtes de sécurité"""
        headers_analysis = {
            'missing': [],
            'present': [],
            'recommendations': []
        }
        
        try:
            response = requests.get(url, headers=self.headers, timeout=10, verify=False)
            headers = response.headers
            
            # Vérifier les en-têtes de sécurité importants
            security_headers = {
                'X-Frame-Options': 'Protection contre le clickjacking',
                'X-Content-Type-Options': 'Protection contre le MIME sniffing',
                'X-XSS-Protection': 'Protection XSS (obsolète mais encore utilisé)',
                'Strict-Transport-Security': 'HSTS - Force HTTPS',
                'Content-Security-Policy': 'CSP - Protection contre XSS',
                'Referrer-Policy': 'Contrôle des informations Referer',
                'Permissions-Policy': 'Contrôle des fonctionnalités du navigateur'
            }
            
            for header, description in security_headers.items():
                if header in headers:
                    headers_analysis['present'].append({
                        'header': header,
                        'value': headers[header],
                        'description': description
                    })
                else:
                    headers_analysis['missing'].append({
                        'header': header,
                        'description': description,
                        'severity': 'High' if header in ['Strict-Transport-Security', 'Content-Security-Policy'] else 'Medium'
                    })
            
            # Recommandations
            if not headers_analysis['present']:
                headers_analysis['recommendations'].append('Aucun en-tête de sécurité présent - Risque élevé')
            if 'Strict-Transport-Security' not in [h['header'] for h in headers_analysis['present']]:
                headers_analysis['recommendations'].append('HSTS manquant - Site vulnérable au downgrade HTTPS')
            if 'Content-Security-Policy' not in [h['header'] for h in headers_analysis['present']]:
                headers_analysis['recommendations'].append('CSP manquant - Protection XSS limitée')
        
        except Exception as e:
            headers_analysis['error'] = str(e)
        
        return headers_analysis
    
    def check_ssl_tls(self, domain: str) -> Dict:
        """Vérifie la configuration SSL/TLS"""
        ssl_analysis = {
            'vulnerabilities': [],
            'recommendations': [],
            'grade': 'A'
        }
        
        if not self.tools['sslscan']:
            return {'error': 'sslscan non disponible'}
        
        result = self._run_wsl_command(['sslscan', domain], timeout=30)
        
        if result.get('success'):
            output = result['stdout']
            
            # Détecter les vulnérabilités
            if 'SSLv2' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'SSLv2 Enabled',
                    'severity': 'Critical',
                    'description': 'SSLv2 est obsolète et vulnérable'
                })
                ssl_analysis['grade'] = 'F'
            
            if 'SSLv3' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'SSLv3 Enabled',
                    'severity': 'High',
                    'description': 'SSLv3 est vulnérable à POODLE'
                })
                if ssl_analysis['grade'] == 'A':
                    ssl_analysis['grade'] = 'C'
            
            if 'TLS 1.0' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'TLS 1.0 Enabled',
                    'severity': 'Medium',
                    'description': 'TLS 1.0 est obsolète'
                })
                if ssl_analysis['grade'] in ['A', 'B']:
                    ssl_analysis['grade'] = 'C'
        
        return ssl_analysis
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> int:
        """Calcule un score de risque (0-100, 100 = très risqué)"""
        if not vulnerabilities:
            return 0
        
        score = 0
        severity_weights = {
            'Critical': 25,
            'High': 15,
            'Medium': 8,
            'Low': 3
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Medium')
            score += severity_weights.get(severity, 5)
        
        return min(100, score)
    
    def analyze_pentest(self, url: str, options: Dict = None) -> Dict:
        """
        Analyse de sécurité complète (Pentest)
        ⚠️ À utiliser uniquement avec autorisation écrite
        
        Args:
            url: URL à analyser
            options: Options de scan (sqlmap, wpscan, nikto, etc.)
        """
        if options is None:
            options = {
                'sqlmap': True,
                'wpscan': True,
                'nikto': True,
                'wapiti': False,  # Plus long
                'security_headers': True,
                'ssl_tls': True
            }
        
        parsed = urlparse(url)
        domain = parsed.netloc or parsed.path.split('/')[0]
        domain = domain.replace('www.', '')
        
        results = {
            'url': url,
            'domain': domain,
            'vulnerabilities': [],
            'sql_injection': {},
            'xss_vulnerabilities': [],
            'csrf_vulnerabilities': [],
            'authentication_issues': [],
            'authorization_issues': [],
            'sensitive_data_exposure': [],
            'security_headers': {},
            'ssl_tls': {},
            'waf_detection': {},
            'cms_vulnerabilities': {},
            'api_security': {},
            'risk_score': 0,
            'summary': {}
        }
        
        # Scan SQL Injection
        if options.get('sqlmap', False):
            try:
                results['sql_injection'] = self.scan_sql_injection(url)
                results['vulnerabilities'].extend(results['sql_injection'].get('vulnerabilities', []))
            except Exception as e:
                results['sql_injection'] = {'error': str(e)}
        
        # Scan WordPress
        if options.get('wpscan', False) and ('wordpress' in url.lower() or 'wp-' in url.lower()):
            try:
                results['cms_vulnerabilities'] = self.scan_wordpress(url)
                results['vulnerabilities'].extend(results['cms_vulnerabilities'].get('vulnerabilities', []))
            except Exception as e:
                results['cms_vulnerabilities'] = {'error': str(e)}
        
        # Scan Nikto
        if options.get('nikto', False):
            try:
                nikto_results = self.scan_nikto(url)
                results['vulnerabilities'].extend(nikto_results.get('vulnerabilities', []))
            except Exception as e:
                results['nikto_error'] = str(e)
        
        # Scan Wapiti (optionnel, plus long)
        if options.get('wapiti', False):
            try:
                wapiti_results = self.scan_wapiti(url)
                results['vulnerabilities'].extend(wapiti_results.get('vulnerabilities', []))
            except Exception as e:
                results['wapiti_error'] = str(e)
        
        # Vérification des en-têtes de sécurité
        if options.get('security_headers', True):
            try:
                results['security_headers'] = self.check_security_headers(url)
            except Exception as e:
                results['security_headers'] = {'error': str(e)}
        
        # Vérification SSL/TLS
        if options.get('ssl_tls', True):
            try:
                results['ssl_tls'] = self.check_ssl_tls(domain)
                results['vulnerabilities'].extend(results['ssl_tls'].get('vulnerabilities', []))
            except Exception as e:
                results['ssl_tls'] = {'error': str(e)}
        
        # Calcul du score de risque
        results['risk_score'] = self.calculate_risk_score(results['vulnerabilities'])
        
        # Résumé
        results['summary'] = {
            'total_vulnerabilities': len(results['vulnerabilities']),
            'critical_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Critical']),
            'high_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'High']),
            'medium_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Medium']),
            'low_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Low']),
            'risk_level': 'Critical' if results['risk_score'] >= 70 else 'High' if results['risk_score'] >= 40 else 'Medium' if results['risk_score'] >= 20 else 'Low'
        }
        
        return results

